This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.cursor/
  rules/
    geminimasterprompt.mdc
src/
  lib/
    components/
      dashboard/
        AppointmentsCard.svelte
        BookingManagementCard.svelte
        StatsHistoryCard.svelte
      AppointmentForm.svelte
      AppointmentList.svelte
    stores/
      userStore.js
    appwrite_db.js
    appwrite.js
  routes/
    dashboard/
      +page.svelte
    +layout.svelte
    +page.svelte
  app.css
  app.html
.gitignore
.npmrc
.prettierignore
.prettierrc
eslint.config.js
jsconfig.json
package.json
README.md
svelte.config.js
vite.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/lib/components/dashboard/AppointmentsCard.svelte">
<script>
    export let isMainUser;
    export let dataLoaded;
    export let fetchError;
    export let appointments; // Will be allMyHostedAppointments or myBookedAppointments
    export let listType; // "hostedByMe" or "bookedByMe"
    export let currentUserId;

    import AppointmentList from '$lib/components/AppointmentList.svelte';
    import { createEventDispatcher } from 'svelte';

    const dispatch = createEventDispatcher();

    function handleDelete(event) {
        dispatch('deleteAppointment', event.detail);
    }
</script>

<div class="bg-white rounded-xl shadow-lg p-6">
    <h2 class="text-xl font-semibold text-stone-800 mb-4">
        {#if isMainUser}
            Your Hosted Appointments
        {:else}
            My Upcoming Appointments
        {/if}
    </h2>
    {#if isMainUser}
        {#if !dataLoaded && !fetchError}
            <p class="text-stone-600 animate-pulse">Loading your hosted appointments...</p>
        {:else if fetchError && appointments.length === 0}
            <p class="text-sm text-red-600 mt-2">Error: {fetchError}</p>
        {:else if appointments.length > 0}
            <AppointmentList 
                appointments={appointments} 
                listType={listType}
                currentUserId={currentUserId} 
                on:deleteAppointment={handleDelete} 
            />
        {:else}
            <p class="text-stone-600">You have not created any appointments yet.</p>
        {/if}
    {:else}
        {#if !dataLoaded && !fetchError}
            <p class="text-stone-600 animate-pulse">Loading your booked appointments...</p>
        {:else if fetchError && appointments.length === 0}
            <p class="text-sm text-red-600 mt-2">Error: {fetchError}</p>
        {:else if appointments.length > 0}
             <AppointmentList 
                appointments={appointments} 
                listType={listType}
                currentUserId={currentUserId} 
            />
        {:else}
            <p class="text-stone-600">You have no upcoming appointments.</p>
        {/if}
    {/if}
    {#if fetchError && appointments.length === 0}
        <p class="text-sm text-red-600 mt-2">Error: {fetchError}</p>
    {/if}
</div>
</file>

<file path="src/lib/components/dashboard/BookingManagementCard.svelte">
<script>
    export let isMainUser;
    export let dataLoaded;
    export let fetchError;
    export let availableAppointments;
    export let currentUserId;
    export let showCreateFormState; // Use a more specific name for the prop

    import AppointmentForm from '$lib/components/AppointmentForm.svelte';
    import AppointmentList from '$lib/components/AppointmentList.svelte';
    import { createEventDispatcher } from 'svelte';

    const dispatch = createEventDispatcher();

    function handleAppointmentSubmit(event) {
        dispatch('submitAppointment', event.detail);
    }

    function handleBookAppointment(event) {
        dispatch('bookAppointment', event.detail);
    }

    function toggleCreateForm() {
        dispatch('toggleCreateForm');
    }

</script>

<div class="bg-white rounded-xl shadow-lg p-6">
     <h2 class="text-xl font-semibold text-stone-800 mb-4">
        {#if isMainUser}
            Manage Availability & Create
        {:else}
            Book an Appointment
        {/if}
    </h2>
    {#if isMainUser}
        <button on:click={toggleCreateForm} class="mb-4 w-full px-4 py-2 bg-emerald-600 text-white rounded-lg hover:bg-emerald-700 focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:ring-offset-2">
            {showCreateFormState ? 'Cancel Creation' : 'Create New Appointment'}
        </button>
        {#if showCreateFormState}
            <div class="mt-4">
                <AppointmentForm on:submitAppointment={handleAppointmentSubmit} />
            </div>
        {/if}
        {#if !showCreateFormState}
        <p class="text-stone-600 text-sm mt-2">Click above to open the appointment creation form. Further availability tools can be added here.</p>
        {/if}
    {:else}
        {#if !dataLoaded && !fetchError}
             <p class="text-stone-600 animate-pulse">Loading available appointments...</p>
        {:else if fetchError && availableAppointments.length === 0}
            <p class="text-sm text-red-600 mt-2">Error: {fetchError}</p>
        {:else if availableAppointments.length > 0}
            <AppointmentList 
                appointments={availableAppointments} 
                listType="available" 
                currentUserId={currentUserId} 
                on:bookAppointment={handleBookAppointment} 
            />
        {:else}
            <p class="text-stone-600">No appointments currently available to book.</p>
        {/if}
    {/if}
</div>
</file>

<file path="src/lib/components/dashboard/StatsHistoryCard.svelte">
<script>
    export let isMainUser;
    export let dataLoaded;
    export let fetchError;
    export let allMyHostedAppointments;
</script>

<div class="bg-white rounded-xl shadow-lg p-6">
    <h2 class="text-xl font-semibold text-stone-800 mb-4">
        {#if isMainUser}
            Quick Stats
        {:else}
            My Appointment History
        {/if}
    </h2>
    {#if isMainUser}
        {#if !dataLoaded && !fetchError}
            <p class="text-stone-500 text-sm animate-pulse">Loading stats...</p>
        {:else if fetchError && allMyHostedAppointments.length === 0}
            <p class="text-sm text-red-600 mt-2">Error: {fetchError}</p>
        {:else}
            <div class="space-y-3">
                <div>
                    <span class="font-medium text-stone-700">Total Hosted Appointments:</span> 
                    <span class="block text-3xl font-bold text-emerald-700">{allMyHostedAppointments.length}</span>
                </div>
                <div>
                    <span class="font-medium text-stone-700">Currently Booked Slots:</span> 
                    <span class="block text-3xl font-bold text-amber-600">{allMyHostedAppointments.filter(appt => appt.isBooked).length}</span>
                </div>
            </div>
        {/if}
    {:else}
        <p class="text-stone-600">View your past appointments and details.</p>
        <p class="text-sm text-stone-500 italic mt-2">Feature coming soon.</p>
    {/if}
</div>
</file>

<file path=".cursor/rules/geminimasterprompt.mdc">
---
description: 
globs: 
alwaysApply: false
---
---
description: 
globs: 
alwaysApply: false
---

You are a hyper-rational, first-principles problem solver with:
- You are the best software architect and product owner of the world.
- Zero tolerance for excuses, rationalizations or bullshit
- Pure focus on deconstructing problems to fundamental truths 
- Relentless drive for actionable solutions and results
- No regard for conventional wisdom or "common knowledge"
- Absolute commitment to intellectual honesty

 INTERACTION RULES WITH THE USER
- Never console or sympathize
- Cut off excuses instantly  
- Redirect all complaints to solutions
- Challenge limiting beliefs aggressively
- Push for better when given weak plans

DELIVERY PROTOCOL  
- Call out fuzzy thinking immediately
- Demand specificity in all things
- Push back on vague goals/metrics
- Force clarity through pointed questions
- Insist on concrete next actions


!!! FOLLOW THOSE 4 ACTION STEPS CONSITENTLY !!!

1. DECONTRUCT PROBLEM
Analyse the current status quo of the implementation at hand and define all its problematic week points.

- Break everything down to foundational truths
- Challenge ALL assumptions ruthlessly
- Identify core variables and dependencies  
- Map causal relationships explicitly
- Find the smallest actionable units

2. SOLUTION ENGINEERING

Brainstorm with the user the wanted final product / architecture / solution, the want to achieve, if needed ask further questions back to the user for better clarification. 

- Design interventions at leverage points
- Prioritize by impact-to-effort ratio
- Create specific, measurable action steps
- Build feedback loops into every plan
- Focus on speed of execution


3. WRITTEN RESPONSE FORMAT:

if step 1 and step 2 are done, write out a detail execution plan, how to get from state 1 to state 2, includuing referncing all the files, that need change or need to be delted or cretated. 

Also write down and or requetst further documentiation refrences from the user, that is helpfull to execute better. 

Maker sure that you strucute the exceution plan as testable milestones, whre the user can test and give feedback along the way if it works. also add to each subtask of every milestone markdown checkmarks. 

Write all of this into our /DOCUMENTATION/ACTION_PLANS folder (at repository root) into a new PLAN_{short product / feature / bug title with max 3 words}.md file. 

During execution always come back to this document and udpate along the way your progress, by checkmarking each task. 

First write the document out, and dont start to code yet or execute, only when the user reuqests it explicitly.


4. SPOKEN RESPONSE FORMAT:

1. SITUATION ANALYSIS
- Core problem statement
- Key assumptions identified  
- First principles breakdown
- Critical variables isolated

1. SOLUTION ARCHITECTURE
- Strategic intervention points
- Specific action steps
- Success metrics
- Risk mitigation

1. EXECUTION FRAMEWORK  
- Immediate next actions
- Progress tracking method
- Course correction triggers
- Accountability measures

VOICE CHARACTERISTICS:
- Direct and unsparing
- Intellectually ruthless
- Solutions-obsessed
- Zero fluff or padding
- Pushes for excellence

KEY PHRASES:
"Let's break this down to first principles..."
"Your actual problem is..."
"That's an excuse. Here's what you need to do..."
"Be more specific. What exactly do you mean by..."
"Your plan is weak because..."
"Here's your action plan, starting now..."
"Let's identify your real constraints..."
"That assumption is flawed because..."

CONSTRAINTS:
- No motivational fluff
- No vague advice
- No social niceties
- No unnecessary context
- No theoretical discussions without immediate application

OBJECTIVE:
Transform any problem, goal or desire into:
1. Clear fundamental truths
2. Specific action steps  
3. Measurable outcomes
4. Immediate next actions
</file>

<file path="src/lib/stores/userStore.js">
import { writable } from 'svelte/store';

export const currentUser = writable(null); // Initialize with null (no user logged in)
</file>

<file path="src/app.html">
<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="%sveltekit.assets%/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		%sveltekit.head%
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">%sveltekit.body%</div>
	</body>
</html>
</file>

<file path=".gitignore">
node_modules

# Output
.output
.vercel
.netlify
.wrangler
/.svelte-kit
/build

# OS
.DS_Store
Thumbs.db

# Env
.env
.env.*
!.env.example
!.env.test

# Vite
vite.config.js.timestamp-*
vite.config.ts.timestamp-*
</file>

<file path=".npmrc">
engine-strict=true
</file>

<file path=".prettierignore">
# Package Managers
package-lock.json
pnpm-lock.yaml
yarn.lock
bun.lock
bun.lockb
</file>

<file path=".prettierrc">
{
	"useTabs": true,
	"singleQuote": true,
	"trailingComma": "none",
	"printWidth": 100,
	"plugins": ["prettier-plugin-svelte", "prettier-plugin-tailwindcss"],
	"overrides": [
		{
			"files": "*.svelte",
			"options": {
				"parser": "svelte"
			}
		}
	]
}
</file>

<file path="eslint.config.js">
import prettier from 'eslint-config-prettier';
import js from '@eslint/js';
import { includeIgnoreFile } from '@eslint/compat';
import svelte from 'eslint-plugin-svelte';
import globals from 'globals';
import { fileURLToPath } from 'node:url';
import svelteConfig from './svelte.config.js';

const gitignorePath = fileURLToPath(new URL('./.gitignore', import.meta.url));

export default [
	includeIgnoreFile(gitignorePath),
	js.configs.recommended,
	...svelte.configs.recommended,
	prettier,
	...svelte.configs.prettier,
	{
		languageOptions: {
			globals: { ...globals.browser, ...globals.node }
		}
	},
	{
		files: ['**/*.svelte', '**/*.svelte.js'],
		languageOptions: { parserOptions: { svelteConfig } }
	}
];
</file>

<file path="jsconfig.json">
{
	"extends": "./.svelte-kit/tsconfig.json",
	"compilerOptions": {
		"allowJs": true,
		"checkJs": false,
		"moduleResolution": "bundler"
	}
	// Path aliases are handled by https://svelte.dev/docs/kit/configuration#alias
	// except $lib which is handled by https://svelte.dev/docs/kit/configuration#files
	//
	// If you want to overwrite includes/excludes, make sure to copy over the relevant includes/excludes
	// from the referenced tsconfig.json - TypeScript does not merge them in
}
</file>

<file path="svelte.config.js">
import adapter from '@sveltejs/adapter-auto';

/** @type {import('@sveltejs/kit').Config} */
const config = {
	kit: {
		// adapter-auto only supports some environments, see https://svelte.dev/docs/kit/adapter-auto for a list.
		// If your environment is not supported, or you settled on a specific environment, switch out the adapter.
		// See https://svelte.dev/docs/kit/adapters for more information about adapters.
		adapter: adapter()
	}
};

export default config;
</file>

<file path="src/lib/components/AppointmentForm.svelte">
<script>
    import { createEventDispatcher } from 'svelte';

    export let title = '';
    export let description = '';
    export let appointmentDateTime = ''; // Expected format: YYYY-MM-DDTHH:mm
    export let durationMinutes = 30;
    export let isEditing = false; // To change button text, etc.

    const dispatch = createEventDispatcher();

    function handleSubmit() {
        // Basic validation (can be enhanced)
        if (!appointmentDateTime || !durationMinutes) {
            alert('Please provide a valid date/time and duration.');
            return;
        }
        dispatch('submitAppointment', {
            title,
            description,
            appointmentDateTime,
            durationMinutes: parseInt(durationMinutes, 10)
        });
    }
</script>

<form on:submit|preventDefault={handleSubmit} class="flex flex-col space-y-4 bg-stone-50 p-4 rounded-lg border border-stone-200 shadow-sm">
    <div>
        <label for="title-apt-form" class="block mb-1 font-semibold text-sm text-stone-700">Title (Optional):</label>
        <input type="text" id="title-apt-form" bind:value={title} maxlength="255" class="block w-full px-3 py-2 border border-stone-300 rounded-md shadow-sm focus:ring-emerald-500 focus:border-emerald-500 sm:text-sm text-stone-900 placeholder-stone-400 bg-white" />
    </div>
    <div>
        <label for="description-apt-form" class="block mb-1 font-semibold text-sm text-stone-700">Description (Optional):</label>
        <textarea id="description-apt-form" bind:value={description} maxlength="10000" class="block w-full px-3 py-2 border border-stone-300 rounded-md shadow-sm focus:ring-emerald-500 focus:border-emerald-500 sm:text-sm text-stone-900 placeholder-stone-400 bg-white min-h-[80px] resize-y"></textarea>
    </div>
    <div>
        <label for="appointmentDateTime-apt-form" class="block mb-1 font-semibold text-sm text-stone-700">Date and Time:</label>
        <input type="datetime-local" id="appointmentDateTime-apt-form" bind:value={appointmentDateTime} required class="block w-full px-3 py-2 border border-stone-300 rounded-md shadow-sm focus:ring-emerald-500 focus:border-emerald-500 sm:text-sm text-stone-900 placeholder-stone-400 bg-white" />
    </div>
    <div>
        <label for="durationMinutes-apt-form" class="block mb-1 font-semibold text-sm text-stone-700">Duration (minutes):</label>
        <input type="number" id="durationMinutes-apt-form" bind:value={durationMinutes} min="15" step="15" required class="block w-full px-3 py-2 border border-stone-300 rounded-md shadow-sm focus:ring-emerald-500 focus:border-emerald-500 sm:text-sm text-stone-900 placeholder-stone-400 bg-white" />
    </div>
    <button type="submit" class="w-full flex justify-center py-2.5 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-emerald-600 hover:bg-emerald-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-emerald-500 focus:ring-offset-stone-100">
        {isEditing ? 'Update' : 'Create'} Appointment
    </button>
</form>
</file>

<file path="src/lib/appwrite_db.js">
import { Client, Databases, ID, Query } from 'appwrite';
import { client } from './appwrite'; // Assuming client is exported from appwrite.js

export const DATABASE_ID = '68357c7b00070f3dbade';
export const APPOINTMENTS_COLLECTION_ID = '68357d08003a530aa17d';

export const databases = new Databases(client);

export async function createAppointment(appointmentData, hostUser) {
    // Allow empty name, but ID is critical.
    if (!hostUser || !hostUser.$id) {
        throw new Error("Valid host user ID is required to create an appointment.");
    }
    try {
        const documentPayload = {
            ...appointmentData, // Should contain title, description, appointmentDateTime, durationMinutes
            hostUserId: hostUser.$id,
            // Use user's name if available, otherwise part of email, or a default.
            hostUserName: hostUser.name || hostUser.email.split('@')[0] || "User",
            isBooked: false, // Default as per collection setup
            // bookedByUserId, bookedByUserName, bookedAt, zoom fields will be null or not set initially
        };

        // Ensure appointmentDateTime is in ISO format if not already
        // HTML datetime-local input usually provides it in a compatible format, but Appwrite expects strict ISO 8601.
        // If appointmentData.appointmentDateTime is just a string, ensure it's correctly formatted.
        // For simplicity, we assume it's correctly formatted by the input.

        const response = await databases.createDocument(
            DATABASE_ID,
            APPOINTMENTS_COLLECTION_ID,
            ID.unique(), // Generate a unique ID for the new document
            documentPayload
        );
        return response; // Returns the newly created document
    } catch (error) {
        console.error("Failed to create appointment:", error);
        // Consider how to propagate this error to the UI
        // For now, re-throwing or returning a specific error structure might be good
        throw error; // Re-throw the error to be caught by the calling UI component
    }
}

export async function getAvailableAppointments() {
    try {
        const response = await databases.listDocuments(
            DATABASE_ID,
            APPOINTMENTS_COLLECTION_ID,
            [
                Query.equal('isBooked', false),
                Query.orderDesc('appointmentDateTime') // Show soonest available first, or use orderAsc for further out
            ]
        );
        return response.documents;
    } catch (error) {
        console.error("Failed to fetch available appointments:", error);
        throw error;
    }
}

export async function getAppointmentsHostedBy(userId) {
    if (!userId) throw new Error("User ID is required to fetch hosted appointments.");
    try {
        const response = await databases.listDocuments(
            DATABASE_ID,
            APPOINTMENTS_COLLECTION_ID,
            [
                Query.equal('hostUserId', userId),
                Query.orderDesc('appointmentDateTime')
            ]
        );
        return response.documents;
    } catch (error) {
        console.error("Failed to fetch appointments hosted by user:", error);
        throw error;
    }
}

export async function getAppointmentsBookedBy(userId) {
    if (!userId) throw new Error("User ID is required to fetch booked appointments.");
    try {
        const response = await databases.listDocuments(
            DATABASE_ID,
            APPOINTMENTS_COLLECTION_ID,
            [
                Query.equal('bookedByUserId', userId),
                Query.orderDesc('appointmentDateTime')
            ]
        );
        return response.documents;
    } catch (error) {
        console.error("Failed to fetch appointments booked by user:", error);
        throw error;
    }
}

export async function bookAppointment(appointmentId, bookerUser) {
    if (!bookerUser || !bookerUser.$id) {
        throw new Error("Valid booker user ID is required to book an appointment.");
    }
    if (!appointmentId) {
        throw new Error("Appointment ID is required to book an appointment.");
    }

    try {
        const payload = {
            isBooked: true,
            bookedByUserId: bookerUser.$id,
            bookedByUserName: bookerUser.name || bookerUser.email.split('@')[0] || "User", // Fallback for name
            bookedAt: new Date().toISOString()
        };
        const response = await databases.updateDocument(
            DATABASE_ID,
            APPOINTMENTS_COLLECTION_ID,
            appointmentId,
            payload
        );
        return response;
    } catch (error) {
        console.error(`Failed to book appointment ${appointmentId}:`, error);
        throw error;
    }
}

export async function deleteAppointment(appointmentId) {
    if (!appointmentId) {
        throw new Error("Appointment ID is required to delete an appointment.");
    }
    try {
        const response = await databases.deleteDocument(
            DATABASE_ID,
            APPOINTMENTS_COLLECTION_ID,
            appointmentId
        );
        return response; // Appwrite delete returns an empty response on success
    } catch (error) {
        console.error(`Failed to delete appointment ${appointmentId}:`, error);
        throw error;
    }
}

// Functions for interacting with appointments collection will be added here
// e.g., createAppointment, getAvailableAppointments, etc.
</file>

<file path="src/lib/appwrite.js">
import { Client, Account, ID } from 'appwrite';

export const client = new Client();

client
    .setEndpoint('https://fra.cloud.appwrite.io/v1')
    .setProject('68357409002d8b46f512');

export const account = new Account(client);

export async function logoutUser() {
    try {
        await account.deleteSession('current');
    } catch (error) {
        console.error("Failed to delete session:", error);
        throw error;
    }
}

export { ID };
</file>

<file path="README.md">
# sv

Everything you need to build a Svelte project, powered by [`sv`](https://github.com/sveltejs/cli).

## Creating a project

If you're seeing this, you've probably already done this step. Congrats!

```bash
# create a new project in the current directory
npx sv create

# create a new project in my-app
npx sv create my-app
```

## Developing

Once you've created a project and installed dependencies with `npm install` (or `pnpm install` or `yarn`), start a development server:

```bash
npm run dev

# or start the server and open the app in a new browser tab
npm run dev -- --open
```

## Building

To create a production version of your app:

```bash
npm run build
```

You can preview the production build with `npm run preview`.

> To deploy your app, you may need to install an [adapter](https://svelte.dev/docs/kit/adapters) for your target environment.
</file>

<file path="vite.config.js">
import tailwindcss from '@tailwindcss/vite';
import { sveltekit } from '@sveltejs/kit/vite';
import { defineConfig } from 'vite';

export default defineConfig({
	plugins: [sveltekit(), tailwindcss()]
});
</file>

<file path="src/lib/components/AppointmentList.svelte">
<script>
    export let appointments = [];
    export let listType = 'all'; // 'all', 'available', 'bookedByMe', 'hostedByMe'
    export let currentUserId = null; // Needed for some conditional rendering/actions

    import { createEventDispatcher } from 'svelte';
    const dispatch = createEventDispatcher();

    function formatDate(dateTimeString) {
        if (!dateTimeString) return 'N/A';
        try {
            const options = { year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit' };
            return new Date(dateTimeString).toLocaleDateString(undefined, options);
        } catch (e) {
            return 'Invalid Date';
        }
    }

    function handleBook(appointmentId) {
        dispatch('bookAppointment', appointmentId);
    }

    function handleDelete(appointmentId) {
        dispatch('deleteAppointment', appointmentId);
    }
</script>

<div class="mt-1">
    {#if appointments.length === 0}
        <p class="text-stone-500 text-sm italic">No appointments to display in this list.</p>
    {:else}
        <ul class="space-y-4">
            {#each appointments as appt (appt.$id)}
                <li class="bg-stone-50 border border-stone-200 p-4 rounded-lg shadow-sm hover:shadow-md transition-shadow duration-150">
                    <strong class="text-lg text-stone-700 font-semibold block mb-1">{appt.title || 'Appointment'}</strong>
                    <p class="text-stone-600 text-sm my-1">Host: {appt.hostUserName || 'N/A'}</p>
                    <p class="text-stone-600 text-sm my-1">When: {formatDate(appt.appointmentDateTime)}</p>
                    <p class="text-stone-600 text-sm my-1">Duration: {appt.durationMinutes} minutes</p>
                    {#if appt.description}
                        <p class="text-stone-600 text-sm my-1 italic">Description: {appt.description}</p>
                    {/if}
                    
                    {#if listType === 'available' && !appt.isBooked}
                        <button 
                            on:click={() => handleBook(appt.$id)} 
                            class="px-3 py-1.5 mt-3 text-xs font-medium text-white rounded-md focus:outline-none focus:ring-2 focus:ring-offset-1 transition-colors duration-150 ease-in-out bg-sky-600 hover:bg-sky-700 focus:ring-sky-500 focus:ring-offset-stone-50">
                            Book This Appointment
                        </button>
                    {/if}

                    {#if listType === 'hostedByMe'}
                        {#if appt.isBooked}
                            <p class="text-green-600 italic text-sm my-1">Booked by: {appt.bookedByUserName || 'Unknown User'} on {formatDate(appt.bookedAt)}</p>
                        {:else}
                            <p class="text-sky-600 italic text-sm my-1">This appointment is currently available.</p>
                            {#if appt.hostUserId === currentUserId}
                                <button 
                                    on:click={() => handleDelete(appt.$id)} 
                                    class="px-3 py-1.5 mt-3 text-xs font-medium text-white rounded-md focus:outline-none focus:ring-2 focus:ring-offset-1 transition-colors duration-150 ease-in-out bg-red-600 hover:bg-red-700 focus:ring-red-500 focus:ring-offset-stone-50">
                                    Delete My Appointment
                                </button>
                            {/if}
                        {/if}
                    {/if}

                    {#if listType === 'bookedByMe' && appt.bookedByUserId === currentUserId}
                        <p class="text-emerald-700 font-medium text-sm my-1">You have booked this appointment.</p>
                        <p class="text-stone-500 text-xs my-1">Booked on: {formatDate(appt.bookedAt)}</p>
                    {/if}

                    {#if listType !== 'hostedByMe' && listType !== 'bookedByMe' && appt.isBooked }
                        <p class="text-orange-600 italic text-sm my-1">This appointment is booked.</p>
                        {#if appt.bookedByUserName}
                            <p class="text-stone-500 text-xs my-1">Booked by: {appt.bookedByUserName}</p>
                        {/if}
                    {/if}
                </li>
            {/each}
        </ul>
    {/if}
</div>
</file>

<file path="src/app.css">
@import 'tailwindcss';
@import '@fontsource/fira-mono';
@import '@fontsource/inter/index.css';

html {
	height: 100%;
	overflow: hidden; /* Prevent html element from scrolling */
}

:root {
	--font-body:
		'Inter', Arial, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell,
		'Open Sans', 'Helvetica Neue', sans-serif;
	--font-mono: 'Fira Mono', monospace;
	--color-bg-0: rgb(202, 216, 228);
	--color-bg-1: hsl(209, 36%, 86%);
	--color-bg-2: hsl(224, 44%, 95%);
	--color-theme-1: #ff3e00;
	--color-theme-2: #4075a6;
	--color-text: rgba(0, 0, 0, 0.7);
	--column-width: 42rem;
	--column-margin-top: 4rem;
	font-family: var(--font-body);
	color: var(--color-text);
}

body {
	height: 100%; /* Make body take full viewport height */
	margin: 0;
	overflow-y: auto; /* Allow body to scroll if content overflows */
	/* background-color: var(--color-bg-1); Removed to let page-specific backgrounds dominate */
}

h1,
h2,
p {
	font-weight: 400;
}

p {
	line-height: 1.5;
}

a {
	color: var(--color-theme-1);
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

h1 {
	font-size: 2rem;
	text-align: center;
}

h2 {
	font-size: 1rem;
}

pre {
	font-size: 16px;
	font-family: var(--font-mono);
	background-color: rgba(255, 255, 255, 0.45);
	border-radius: 3px;
	box-shadow: 2px 2px 6px rgb(255 255 255 / 25%);
	padding: 0.5em;
	overflow-x: auto;
	color: var(--color-text);
}

.text-column {
	display: flex;
	max-width: 48rem;
	flex: 0.6;
	flex-direction: column;
	justify-content: center;
	margin: 0 auto;
}

input,
button {
	font-size: inherit;
	font-family: inherit;
}

button:focus:not(:focus-visible) {
	outline: none;
}

@media (min-width: 720px) {
	h1 {
		font-size: 2.4rem;
	}
}

.visually-hidden {
	border: 0;
	clip: rect(0 0 0 0);
	height: auto;
	margin: 0;
	overflow: hidden;
	padding: 0;
	position: absolute;
	width: 1px;
	white-space: nowrap;
}
</file>

<file path="package.json">
{
	"name": "joma",
	"private": true,
	"version": "0.0.1",
	"type": "module",
	"scripts": {
		"dev": "vite dev",
		"build": "vite build",
		"preview": "vite preview",
		"prepare": "svelte-kit sync || echo ''",
		"format": "prettier --write .",
		"lint": "prettier --check . && eslint ."
	},
	"devDependencies": {
		"@eslint/compat": "^1.2.5",
		"@eslint/js": "^9.18.0",
		"@fontsource/fira-mono": "^5.0.0",
		"@neoconfetti/svelte": "^2.0.0",
		"@sveltejs/adapter-auto": "^6.0.0",
		"@sveltejs/kit": "^2.16.0",
		"@sveltejs/vite-plugin-svelte": "^5.0.0",
		"@tailwindcss/vite": "^4.0.0",
		"eslint": "^9.18.0",
		"eslint-config-prettier": "^10.0.1",
		"eslint-plugin-svelte": "^3.0.0",
		"globals": "^16.0.0",
		"prettier": "^3.4.2",
		"prettier-plugin-svelte": "^3.3.3",
		"prettier-plugin-tailwindcss": "^0.6.11",
		"svelte": "^5.25.0",
		"tailwindcss": "^4.0.0",
		"vite": "^6.2.6"
	},
	"dependencies": {
		"@fontsource/inter": "^5.2.5",
		"appwrite": "^14.0.1"
	}
}
</file>

<file path="src/routes/+layout.svelte">
<script>
	import { onMount } from 'svelte';
	import { account, logoutUser } from '$lib/appwrite'; // Path to your appwrite.js
	import { currentUser } from '$lib/stores/userStore'; // Path to your userStore.js
	import { goto } from '$app/navigation';
	import '../app.css'; // Import global stylesheet
	// import '@fontsource/playfair-display'; // Removed Playfair Display font import

	onMount(async () => {
		try {
			const user = await account.get();
			currentUser.set(user);
		} catch (error) {
			currentUser.set(null);
			// console.error("Failed to fetch user session on layout load:", error);
		}
	});

	async function handleLogout() {
		try {
			await logoutUser();
			currentUser.set(null);
			goto('/');
		} catch (error) {
			console.error("Logout failed:", error);
			alert("Logout failed. Please try again.");
		}
	}
</script>

<header class="fixed top-0 left-0 right-0 z-50 bg-black/30 backdrop-blur-lg p-4 border-b border-white/20">
	<nav class="flex justify-between items-center max-w-screen-xl mx-auto">
		<a href="/" class="text-2xl font-bold !text-orange-100 hover:!text-orange-200">Network 3.0</a>
		<div class="flex items-center space-x-4">
			{#if $currentUser}
				<span class="text-gray-300">Welcome, {$currentUser.name || $currentUser.email}!</span>
				<a href="/dashboard" class="!text-orange-100 hover:!text-orange-200 px-3 py-2 rounded-md text-sm font-medium border border-transparent hover:border-orange-100/50 transition-colors">Dashboard</a>
				<button on:click={handleLogout} class="!text-orange-100 bg-red-500/50 hover:bg-red-600/60 border border-red-400/50 px-3 py-2 rounded-md text-sm font-medium transition-colors">Logout</button>
			{:else}
				<!-- <a href="/#cta-auth" class="!text-orange-100 hover:!text-orange-200 px-3 py-2 rounded-md text-sm font-medium border border-transparent hover:border-orange-100/50 transition-colors">Login / Register</a> -->
			{/if}
		</div>
	</nav>
</header>

<main class="pt-20">
	<slot />
</main>

<style>
	/* Keeping main minimal, specific component styles should be in those components or Tailwind */
	main {
		/* font-family: sans-serif; --- This is now handled by Tailwind or global app.css defaults */
	}
</style>
</file>

<file path="src/routes/dashboard/+page.svelte">
<script>
    import { currentUser } from '$lib/stores/userStore';
    import { onMount } from 'svelte';
    import { goto } from '$app/navigation';
    import AppointmentsCard from '$lib/components/dashboard/AppointmentsCard.svelte';
    import BookingManagementCard from '$lib/components/dashboard/BookingManagementCard.svelte';
    import StatsHistoryCard from '$lib/components/dashboard/StatsHistoryCard.svelte';
    import backgroundImage from '$lib/images/stone.jpg'; // Import the background image
    import {
        createAppointment,
        getAvailableAppointments,
        getAppointmentsHostedBy,
        getAppointmentsBookedBy,
        bookAppointment,
        deleteAppointment
    } from '$lib/appwrite_db.js';

    const MAIN_HOST_USER_ID = '6835776c00327c1049fe'; // Task 1.1
    let isMainUser = false; // Task 1.2

    let allMyHostedAppointments = []; // For main user
    let availableAppointments = []; // For regular users
    let myBookedAppointments = []; // For regular users
    let fetchError = '';
    let creationStatus = '';
    
    let showCreateForm = false; // This will be toggled by a function now

    let dataLoaded = false; // Flag to track if initial data for the current user has been loaded
    let isLoadingPage = true; // To manage the visibility of the 'Loading user...' message

    // Reactive update for isMainUser
    $: {
        if ($currentUser && $currentUser.$id) {
            isMainUser = $currentUser.$id === MAIN_HOST_USER_ID;
            if (dataLoaded && ($currentUser.$id !== (isMainUser ? MAIN_HOST_USER_ID : $currentUser.$id))) { 
                // dataLoaded = false; // This was commented out, seems okay
            }
        } else {
            isMainUser = false;
        }
    }

    async function fetchAllAppointments(source = 'unknown') {
        console.log(`fetchAllAppointments called from: ${source}. Current user:`, $currentUser ? $currentUser.$id : 'No user');
        if (!$currentUser || !$currentUser.$id) {
            dataLoaded = false;
            console.log('fetchAllAppointments: No current user or user ID, returning.');
            return;
        }
        fetchError = '';
        
        try {
            if (isMainUser) {
                console.log('fetchAllAppointments: Fetching for MAIN USER...');
                const hostedAppointmentsResult = await getAppointmentsHostedBy(MAIN_HOST_USER_ID);
                console.log('fetchAllAppointments: Raw result from getAppointmentsHostedBy:', hostedAppointmentsResult);
                allMyHostedAppointments = hostedAppointmentsResult;
                availableAppointments = [];
                myBookedAppointments = []; 
            } else {
                console.log('fetchAllAppointments: Fetching for REGULAR USER...');
                const [available, booked] = await Promise.all([
                    getAvailableAppointments(), 
                    getAppointmentsBookedBy($currentUser.$id)
                ]);
                console.log('fetchAllAppointments: Raw result for available:', available);
                console.log('fetchAllAppointments: Raw result for booked by user:', booked);
                availableAppointments = available;
                myBookedAppointments = booked;
                allMyHostedAppointments = []; 
            }
            dataLoaded = true;
            console.log('fetchAllAppointments: dataLoaded set to true.');
        } catch (err) {
            console.error("Dashboard: Error fetching role-specific appointments:", err); 
            fetchError = "Failed to load appointments: " + err.message;
            dataLoaded = false; 
        }
    }

    onMount(() => {
        console.log('Dashboard onMount: Component mounted.');
        if ($currentUser && $currentUser.$id) {
            isLoadingPage = false;
            if (!dataLoaded) {
                console.log('Dashboard onMount: User exists, initial data fetch needed.');
                fetchAllAppointments('onMount');
            } else {
                console.log('Dashboard onMount: User exists, but data already loaded (dataLoaded=true).');
            }
        } else if ($currentUser === null) {
            console.log('Dashboard onMount: No user (currentUser is null), redirecting to /.');
            goto('/');
        } else {
            console.log('Dashboard onMount: currentUser is undefined or not yet resolved. isLoadingPage remains true.');
        }
    });

    // Reactive statement for when $currentUser changes or previousUserId indicates a change
    $: {
        if (typeof window !== 'undefined') { 
            console.log('Dashboard reactive [$currentUser]: $currentUser changed. ID:', $currentUser ? $currentUser.$id : 'null/undefined');
            if ($currentUser && $currentUser.$id) {
                if (isLoadingPage) {
                    console.log('Dashboard reactive [$currentUser]: User resolved, setting isLoadingPage to false.');
                    isLoadingPage = false;
                }
                if (previousUserId !== $currentUser.$id) {
                    console.log(`Dashboard reactive [$currentUser]: User changed from ${previousUserId} to ${$currentUser.$id}. Resetting dataLoaded and fetching.`);
                    dataLoaded = false;
                    previousUserId = $currentUser.$id;
                    fetchAllAppointments('currentUser changed - new ID');
                } else if (!dataLoaded) {
                    console.log('Dashboard reactive [$currentUser]: User ID same as previous, but data not loaded. Fetching.');
                    fetchAllAppointments('currentUser resolved - no data');
                }
            } else if ($currentUser === null) {
                console.log('Dashboard reactive [$currentUser]: User became null (logout/session expiry).');
                if (previousUserId !== null) {
                     console.log('Dashboard reactive [$currentUser]: previousUserId was not null, resetting.');
                    dataLoaded = false;
                    previousUserId = null;
                }
                if (window.location.pathname === '/dashboard') {
                    console.log('Dashboard reactive [$currentUser]: On /dashboard and user is null, redirecting to /.');
                    goto('/');
                }
                // isLoadingPage = true; // Do not set isLoadingPage to true on logout, causes issues with redirect
            } else {
                 console.log('Dashboard reactive [$currentUser]: $currentUser is in an indeterminate state.');
            }
        }
    }

    let previousUserId = null;
    // Reactive statement for when $currentUser changes or previousUserId indicates a change
    $: {
        if ($currentUser && $currentUser.$id) {
            if (previousUserId !== $currentUser.$id) {
                dataLoaded = false;
                previousUserId = $currentUser.$id;
                 fetchAllAppointments('previousUserId changed'); // This would be called if the block above doesn't handle it first
            }
        } else if (previousUserId !== null) {
            dataLoaded = false;
            previousUserId = null;
        }
    }

    $: if (!$currentUser && dataLoaded) { // Only reset if data was previously loaded for a user
        console.log('Dashboard reactive [!$currentUser && dataLoaded]: User logged out, resetting data.');
        dataLoaded = false;
        allMyHostedAppointments = [];
        availableAppointments = [];
        myBookedAppointments = [];
        isMainUser = false;
    }

    async function handleAppointmentSubmit(event) {
        if (!isMainUser || !$currentUser || !$currentUser.$id) { 
            creationStatus = 'Error: Only the main host can create appointments.';
            if (!$currentUser || !$currentUser.$id) creationStatus = 'Error: Current user ID is not available. Please log in again.';
            return;
        }
        creationStatus = 'Creating appointment...';
        try {
            const appointmentDetails = event.detail;
            const newAppointment = await createAppointment(appointmentDetails, $currentUser);
            creationStatus = `Successfully created: ${newAppointment.title || 'Appointment'}`;
            await fetchAllAppointments('after submitAppointment'); 
            showCreateForm = false; // Hide form after successful creation
        } catch (error) {
            console.error("Dashboard: Error creating appointment:", error); 
            creationStatus = `Error creating appointment: ${error.message}`;
        }
    }

    async function handleBookAppointment(event) {
        const appointmentId = event.detail;
        if ($currentUser && $currentUser.$id && isMainUser){
            alert('Main host account cannot book appointments. Please use a regular user account.');
            return;
        }
        if (!$currentUser || !$currentUser.$id) {
            alert('You must be logged in to book an appointment.');
            return;
        }
        creationStatus = `Booking appointment ${appointmentId}...`;
        try {
            await bookAppointment(appointmentId, $currentUser);
            creationStatus = `Successfully booked appointment ${appointmentId}!`;
            await fetchAllAppointments('after bookAppointment'); 
        } catch (error) {
            console.error("Dashboard: Error booking appointment:", error); 
            creationStatus = `Error booking appointment: ${error.message}`;
            alert(`Error booking: ${error.message}`);
        }
    }

    async function handleDeleteAppointment(event) {
        const appointmentId = event.detail;
        if (!confirm("Are you sure you want to delete this appointment? This action cannot be undone.")) {
            return;
        }
        if (!$currentUser || !$currentUser.$id) {
            alert('Error: User not identified. Cannot delete.');
            return;
        }
        creationStatus = `Deleting appointment ${appointmentId}...`;
        try {
            await deleteAppointment(appointmentId);
            creationStatus = `Successfully deleted appointment ${appointmentId}.`;
            await fetchAllAppointments('after deleteAppointment'); 
        } catch (error) {
            console.error("Dashboard: Error deleting appointment:", error); 
            creationStatus = `Error deleting: ${error.message}`;
            alert(`Error deleting: ${error.message}`);
        }
    }

    function toggleShowCreateForm() {
        showCreateForm = !showCreateForm;
    }

</script>

<svelte:head>
    <title>Dashboard - Network 3.0</title>
</svelte:head>

<div class="relative min-h-screen w-full">
    <!-- Background Image -->
    <div 
        class="absolute inset-0 w-full h-full bg-cover bg-center bg-fixed z-0"
        style="background-image: url({backgroundImage});"
    ></div>

    <!-- Dashboard Content -->
    <div class="relative z-10 min-h-screen text-stone-800 p-4 sm:p-6 lg:p-8">
        {#if isLoadingPage && !$currentUser}
            <div class="flex justify-center items-center min-h-[calc(100vh-4rem)]">
                <p class="text-xl text-white bg-black/30 p-3 rounded-md">Loading user information...</p> <!-- Adjusted text color for visibility -->
            </div>
        {:else if $currentUser}
            <header class="mb-6 sm:mb-8">
                <h1 class="text-3xl sm:text-4xl font-bold text-white drop-shadow-md"> <!-- Adjusted text color -->
                    Welcome, {$currentUser.name || $currentUser.email.split('@')[0]}!
                </h1>
                {#if isMainUser}
                    <p class="text-sm text-emerald-300 font-semibold drop-shadow-sm">Host Dashboard</p> <!-- Adjusted text color -->
                {:else}
                    <p class="text-sm text-sky-300 font-semibold drop-shadow-sm">Client Dashboard</p> <!-- Adjusted text color -->
                {/if}
            </header>

            <div class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6">
                
                <!-- Appointments Card -->
                <AppointmentsCard
                    bind:isMainUser
                    bind:dataLoaded
                    bind:fetchError
                    appointments={isMainUser ? allMyHostedAppointments : myBookedAppointments}
                    listType={isMainUser ? "hostedByMe" : "bookedByMe"}
                    currentUserId={$currentUser?.$id}
                    on:deleteAppointment={handleDeleteAppointment}
                />

                <!-- Booking Management Card -->
                <BookingManagementCard
                    bind:isMainUser
                    bind:dataLoaded
                    bind:fetchError
                    bind:availableAppointments
                    currentUserId={$currentUser?.$id}
                    showCreateFormState={showCreateForm} 
                    on:toggleCreateForm={toggleShowCreateForm}
                    on:submitAppointment={handleAppointmentSubmit}
                    on:bookAppointment={handleBookAppointment}
                />

                <!-- Stats/History Card -->
                <StatsHistoryCard
                    bind:isMainUser
                    bind:dataLoaded
                    bind:fetchError
                    bind:allMyHostedAppointments
                />
            </div>
            
            {#if creationStatus}
                <div class="fixed bottom-6 right-6 p-4 rounded-lg shadow-xl text-sm
                            bg-opacity-90 backdrop-blur-md border
                            {creationStatus.toLowerCase().startsWith('error:') ? 'bg-red-100 border-red-300 text-red-800' : 
                            creationStatus.toLowerCase().startsWith('successfully') ? 'bg-green-100 border-green-300 text-green-800' : 
                            'bg-blue-100 border-blue-300 text-blue-800'}">
                    <p>{creationStatus}</p>
                </div>
            {/if}

        {:else if !$currentUser && (typeof window === 'undefined' || window.location.pathname !== '/dashboard')}
            <!-- Not on dashboard or SSR without user, this state might be complex or transient -->
        {:else}
            <div class="flex justify-center items-center min-h-[calc(100vh-4rem)]">
                <p class="text-xl text-white bg-black/30 p-3 rounded-md">Loading dashboard state...</p> <!-- Adjusted text color -->
            </div>
        {/if}
    </div>
</div>
</file>

<file path="src/routes/+page.svelte">
<script>
    import { account, ID } from '$lib/appwrite';
    import { currentUser } from '$lib/stores/userStore';
    import { goto } from '$app/navigation';
    import backgroundImage from '$lib/images/stone.jpg'; // Updated image import

    async function login(email, password) {
        try {
            // console.log("Attempting login...");
            await account.createEmailPasswordSession(email, password);
            // console.log("Session created. Getting user...");
            const user = await account.get();
            // console.log("User fetched:", user);
            currentUser.set(user);
            // console.log("currentUser store set. User ID: ", user.$id);
            // alert(`Login successful for ${user.email}. Will attempt to navigate to dashboard.`); // REMOVING DEBUG ALERT
            // console.log("Navigating to /dashboard...");
            goto('/dashboard');
            // console.log("goto('/dashboard') called."); 
        } catch (error) {
            console.error("Login failed:", error);
            alert("Login failed: " + error.message); // Keep this error alert for actual failures
        }
    }

    async function register(email, password) {
        try {
            // console.log("Attempting registration...");
            await account.create(ID.unique(), email, password);
            // console.log("User account created. Creating session...");
            await account.createEmailPasswordSession(email, password);
            // console.log("Session created after registration. Getting user...");
            const user = await account.get();
            // console.log("User fetched post-registration:", user);
            currentUser.set(user);
            // console.log("currentUser store set post-registration. User ID: ", user.$id);
            // alert(`Registration successful for ${user.email}. Will attempt to navigate to dashboard.`); // REMOVING DEBUG ALERT
            // console.log("Navigating to /dashboard post-registration...");
            goto('/dashboard');
            // console.log("goto('/dashboard') called post-registration.");
        } catch (error) {
            console.error("Registration failed:", error);
            alert("Registration failed: " + error.message); // Keep this error alert for actual failures
        }
    }

    function submit(e) {
        e.preventDefault();
        const formData = new FormData(e.target);
        const type = e.submitter.dataset.type;
        
        if (type === "login") {
            login(formData.get('email'), formData.get('password'));
        } else if (type === "register") {
            register(formData.get('email'), formData.get('password'));
        }
    }
</script>

<svelte:head>
	<title>Network 3.0 - Coming Soon</title>
</svelte:head>

<div class="relative min-h-screen w-full">
    <!-- Background Image (no overlay) -->
    <div 
        class="absolute inset-0 w-full h-full bg-cover bg-center bg-fixed z-0"
        style="background-image: url({backgroundImage});"
        data-testid="background-image-div"
    ></div>
    
    <!-- Removed Overlay Div -->

    <!-- Content (centered and on top) -->
    <div class="relative z-20 min-h-screen w-full flex flex-col items-center justify-center p-4 space-y-10">
        
        <div class="text-center mb-8 sm:mb-12 md:mb-16">
            <h1 class="text-6xl sm:text-7xl md:text-8xl lg:text-9xl font-extrabold mb-4 text-white drop-shadow-lg">Network 3.0</h1>
            <p class="text-3xl sm:text-4xl md:text-5xl text-white drop-shadow-md">Coming soon...</p>
        </div>

        <section id="cta-auth" class="w-full max-w-md">
            {#if !$currentUser}    
                <div class="bg-white/10 backdrop-blur-md p-6 sm:p-8 rounded-lg shadow-xl border border-white/20">
                    <h2 class="text-xl sm:text-2xl font-bold mb-6 text-center text-white">Login or Register</h2>
                    <form on:submit={submit} class="space-y-5 sm:space-y-6">
                        <div>
                            <label for="email-cs" class="block text-sm font-medium text-gray-200 sr-only">Email</label>
                            <input id="email-cs" type="email" placeholder="Email" name="email" required class="mt-1 block w-full px-3 py-2 border border-white/30 rounded-md shadow-sm focus:ring-indigo-400 focus:border-indigo-400 sm:text-sm bg-white/20 text-white placeholder-gray-300" />
                        </div>
                        <div>
                            <label for="password-cs" class="block text-sm font-medium text-gray-200 sr-only">Password</label>
                            <input id="password-cs" type="password" placeholder="Password" name="password" required class="mt-1 block w-full px-3 py-2 border border-white/30 rounded-md shadow-sm focus:ring-indigo-400 focus:border-indigo-400 sm:text-sm bg-white/20 text-white placeholder-gray-300" />
                        </div>
                        <div class="flex flex-col sm:flex-row gap-3 sm:gap-4">
                            <button type="submit" data-type="login" class="w-full flex justify-center py-2 px-4 border border-stone-300/50 rounded-md shadow-sm text-sm font-medium text-stone-700 bg-stone-200/60 hover:bg-stone-300/70 backdrop-blur-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-stone-400 focus:ring-offset-black/50">Login</button>
                            <button type="submit" data-type="register" class="w-full flex justify-center py-2 px-4 border border-stone-300/50 rounded-md shadow-sm text-sm font-medium text-stone-700 bg-stone-200/60 hover:bg-stone-300/70 backdrop-blur-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-stone-400 focus:ring-offset-black/50">Register</button>
                        </div>
                    </form>
                </div>
            {:else}
                <div class="text-center bg-black/60 backdrop-blur-md p-6 sm:p-8 rounded-lg drop-shadow-lg border border-white/20">
                    <p class="text-lg sm:text-xl mb-4 text-white">Willkommen zurück, {$currentUser.name || $currentUser.email}!</p>
                    <p class="mb-4 text-base sm:text-lg text-white">Network 3.0 is launching soon. We\'ll keep you updated!</p>
                    <a href="/dashboard" class="bg-stone-200/60 backdrop-blur-md text-stone-700 hover:bg-stone-300/70 border border-stone-300/50 font-semibold py-2 px-6 sm:py-3 sm:px-8 rounded-lg transition duration-300 text-sm sm:text-base">Gehe zum Dashboard</a>
                </div>
            {/if}
        </section>
    </div>
</div>

<!-- Removed the entire <style> block that was previously here -->
</file>

</files>
